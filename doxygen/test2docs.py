#  AUI Framework - Declarative UI toolkit for modern C++20
#  Copyright (C) 2020-2024 Alex2772 and Contributors
#
#  SPDX-License-Identifier: MPL-2.0
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.


# This Python script scans aui.*/tests/**.cpp files for the following line:
#
# // AUI_DOCS_OUTPUT: <path>
#
# If this line exists, the script generates a file under that path and places contents of the cpp file to the file
# with some preprocessing to make a suitable markdown file which can be used by Doxygen.
#
# This approach allows to generate decent docs with examples which would work based on the fact that they are generated
# from real tests.

import os
import os
import re
from pathlib import Path

REGEX_DIR = re.compile(r'.*(aui\..+)/tests')
REGEX_AUI_DOCS_OUTPUT = re.compile(r'^// ?AUI_DOCS_OUTPUT: ?(.+)\n$')
REGEX_COMMENT = re.compile(r'\s*// ?(.*)\n?$')

# TEST_F(UIDataBindingTest, AProperty) { // HEADER
REGEX_TESTCASE_HEADER = re.compile(r'TEST_F\(.+, (.+)\) ?\{ ?// ?HEADER')

assert REGEX_DIR.match("/home/aui.views/tests")
assert not REGEX_DIR.match("/home/aui.views/src")
assert REGEX_COMMENT.match("   // AUI_DOCS_CODE_BEGIN\n")

def scan_cpp_files(path: Path):
    for root, dirs, files in os.walk(path):
        for file in files:
            if file.endswith('.cpp') and REGEX_DIR.match(root):
                with open(Path(root) / file, 'r') as f:
                    for line in f.readlines():
                        if REGEX_AUI_DOCS_OUTPUT.match(line):
                            yield Path(root) / file

def process_code_begin(iter):
    for line in iter:
        if "AUI_DOCS_CODE_END" in line:
            return
        yield line


def strip_indentation(code):
    """
    Removes unnecessary indentation.

    processes code as follows:
    [
      "    int main() {",
      "        return 0",
      "    }",
    ]

    to

    [
      "int main() {",
      "    return 0",
      "}",
    ]

    :param code: list of code lines
    :return modified list of code lines
    """
    min_leading_spaces = min([len(i) - len(i.lstrip()) for i in code])
    return [line[min_leading_spaces:] for line in code]



def process_cpp_file(input: Path):

    with open(input, 'r') as fis:
        lines = iter(fis.readlines())
        for line in lines:
            if m := REGEX_AUI_DOCS_OUTPUT.match(line):
                output = Path(m.group(1))
                # Create a directory and file at the specified path if they don't exist
                output_dir = Path(output).parent
                os.makedirs(output_dir, exist_ok=True)
                break

        IS_MD = str(output).endswith(".md")
        with open(output, 'w') as fos:
            if IS_MD:
                def emit_line():
                    fos.write("\n")
                CODE_BEGIN = "```cpp"
                CODE_END = "```"
            else:
                def emit_line():
                    fos.write("\n * ")
                fos.write("\n\n\n/* !!!!!!!!!!!!!!!! THIS FILE IS AUTOGENERATED !!!!!!!!!!!!!!!! */\n\n\n")
                fos.write("/**")
                emit_line()
                CODE_BEGIN = "@code{cpp}"
                CODE_END = "@endcode"

            for line in lines:
                if match := REGEX_TESTCASE_HEADER.match(line):
                    emit_line()
                    fos.write("## ")
                    fos.write(match.group(1).replace("_", " "))
                    emit_line()
                    continue

                if comment := REGEX_COMMENT.match(line):
                    comment_contents = comment.group(1)
                    if "AUI_DOCS_CODE_BEGIN" in comment_contents:
                        fos.write(CODE_BEGIN)
                        emit_line()
                        code = [i for i in process_code_begin(lines)]
                        for line in strip_indentation(code):
                            line = line.rstrip("\n")
                            if line.endswith("// HIDE"):
                                continue
                            fos.write(line)
                            emit_line()
                        fos.write(CODE_END)
                        emit_line()
                        emit_line()
                        continue
                    fos.write(comment_contents)
                    emit_line()
            if not IS_MD:
                fos.write("\n */")


if __name__ == '__main__':
    if not Path('README.md').exists():
        print("Error: README.md does not exist in the current working directory. Are you running from proper working dir?")
        exit(-1)

    suitable_cpp_files = [i for i in scan_cpp_files(Path.cwd())]
    print('Files to process:', suitable_cpp_files)
    for path in suitable_cpp_files:
        process_cpp_file(path)

