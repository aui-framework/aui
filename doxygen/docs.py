#  AUI Framework - Declarative UI toolkit for modern C++20
#  Copyright (C) 2020-2024 Alex2772 and Contributors
#
#  SPDX-License-Identifier: MPL-2.0
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
import collections
import enum
import os
import os
import re
import shutil
import subprocess
from pathlib import Path

########################################################################################################################


CONFIG = {
    'output': "doxygen/out/html/",
    'copy_to_output': [],
    'doxygen_annoyances': [
        "Internal inconsistency: scope for class",
        "error: no uniquely matching class member found",

    ],
}

########################################################################################################################

REGEX_DIR = re.compile(r'.*(aui\..+)/tests')
assert REGEX_DIR.match("/home/aui.views/tests")
assert not REGEX_DIR.match("/home/aui.views/src")

REGEX_AUI_DOCS_OUTPUT = re.compile(r'^// ?AUI_DOCS_OUTPUT: ?(.+)\n$')

REGEX_COMMENT = re.compile(r'\s*// ?(.*)\n?$')
assert REGEX_COMMENT.match("   // AUI_DOCS_CODE_BEGIN\n")

# TEST_F(UIDataBindingTest, AProperty) { // HEADER
REGEX_TESTCASE_HEADER = re.compile(r'TEST_F\(.+, (.+)\) ?\{ ?// ?HEADER')

REGEX_INGROUP = re.compile(r'.*([@\\]ingroup ?\w*).*')
assert REGEX_INGROUP.match("   * @ingroup")
assert REGEX_INGROUP.match("   * @ingroup sadkal")

REGEX_INCLUDE = re.compile("#include [\"<](.+)[\">].*")
assert REGEX_INCLUDE.match("#include <SOME.h> ikf").group(1) == "SOME.h"
assert REGEX_INCLUDE.match("#include \"SOME.h\" ikf").group(1) == "SOME.h"

def scan_cpp_files(path: Path):
    """
    # scans aui.*/tests/**.cpp files for the following line:
    #
    # // AUI_DOCS_OUTPUT: <path>
    """
    for root, dirs, files in os.walk(path):
        for file in files:
            if file.endswith('.cpp') and REGEX_DIR.match(root):
                with open(Path(root) / file, 'r') as f:
                    for line in f.readlines():
                        if REGEX_AUI_DOCS_OUTPUT.match(line):
                            yield Path(root) / file


def process_code_begin(iter):
    for line in iter:
        if "AUI_DOCS_CODE_END" in line:
            return
        yield line


def strip_indentation(code):
    """
    Removes unnecessary indentation.

    processes code as follows:
    [
      "    int main() {",
      "        return 0",
      "    }",
    ]

    to

    [
      "int main() {",
      "    return 0",
      "}",
    ]

    :param code: list of code lines
    :return modified list of code lines
    """
    min_leading_spaces = min([len(i) - len(i.lstrip()) for i in code])
    return [line[min_leading_spaces:] for line in code]


def process_cpp_file(input: Path):
    with open(input, 'r') as fis:
        lines = iter(fis.readlines())
        for line in lines:
            if m := REGEX_AUI_DOCS_OUTPUT.match(line):
                output = Path(m.group(1))
                # Create a directory and file at the specified path if they don't exist
                output_dir = Path(output).parent
                os.makedirs(output_dir, exist_ok=True)
                break

        IS_MD = str(output).endswith(".md")
        with open(output, 'w') as fos:
            if IS_MD:
                def emit_line():
                    fos.write("\n")

                CODE_BEGIN = "```cpp"
                CODE_END = "```"
            else:
                def emit_line():
                    fos.write("\n * ")

                fos.write("\n\n\n/* !!!!!!!!!!!!!!!! THIS FILE IS AUTOGENERATED !!!!!!!!!!!!!!!! */\n\n\n")
                fos.write("/**")
                emit_line()
                CODE_BEGIN = "@code{cpp}"
                CODE_END = "@endcode"

            for line in lines:
                if match := REGEX_TESTCASE_HEADER.match(line):
                    emit_line()
                    fos.write("## ")
                    fos.write(match.group(1).replace("_", " "))
                    fos.write(" {#")
                    fos.write(match.group(1))
                    fos.write("}")
                    emit_line()
                    continue

                if comment := REGEX_COMMENT.match(line):
                    comment_contents = comment.group(1)
                    if "AUI_DOCS_CODE_BEGIN" in comment_contents:
                        fos.write(CODE_BEGIN)
                        emit_line()
                        code = [i for i in process_code_begin(lines)]
                        for line in strip_indentation(code):
                            line = line.rstrip("\n")
                            if line.endswith("// HIDE"):
                                continue
                            fos.write(line)
                            emit_line()
                        fos.write(CODE_END)
                        emit_line()
                        emit_line()
                        continue
                    fos.write(comment_contents)
                    emit_line()
            if not IS_MD:
                fos.write("\n */")


def doxygen_is_interesting_error(line):
    for i in CONFIG["doxygen_annoyances"]:
        if i in line:
            return False
    return True


def doxygen_parse_stderr(stderr):
    it = iter(stderr.decode('utf-8').split('\n'))

    current_error_lines = []

    for i in it:
        if i.startswith("/") or i.startswith("<unknown"):  # indicates a start of error
            if current_error_lines:
                if doxygen_is_interesting_error(current_error_lines[0]):
                    yield "\n".join(current_error_lines)
                current_error_lines = []

        current_error_lines.append(i)

    if current_error_lines:
        if doxygen_is_interesting_error(current_error_lines[0]):
            yield "\n".join(current_error_lines)
            current_error_lines = []

error_flag = False

def report_error(file: Path, error_string: str, line: int = None):
    global error_flag
    error_flag = True
    line_string = ""
    if line is not None:
        line_string = f":{line}"
    print(f"{file.absolute()}{line_string}: {error_string}")


def generate_docs_from_tests():
    """
    The script generates a file under that path and places contents of the cpp file to the file
    with some preprocessing to make a suitable markdown file which can be used by Doxygen.

    This approach allows to generate decent docs with examples which would work based on the fact that they are generated
    from real tests.
    """

    suitable_cpp_files = [i for i in scan_cpp_files(Path.cwd())]
    print('Tests to generate docs from:', suitable_cpp_files)
    for path in suitable_cpp_files:
        process_cpp_file(path)

def invoke_doxygen():
    print("Doxygen version:", subprocess.run("doxygen -v", shell=True, capture_output=True).stdout.decode('utf-8'))
    result = subprocess.run("doxygen doxygen/Doxyfile", shell=True, capture_output=True)
    doxygen_errors = doxygen_parse_stderr(result.stderr)

    count = 0
    for i in doxygen_errors:
        count += 1
        print(i)
    if count > 0:
        print(f"Error: doxygen failed: {count} error(s).")
        global error_flag
        error_flag = True


class PatchMode(enum.Enum):
    INSERT_AFTER = enum.auto()
    DELETE_LINE = enum.auto()


def patch(target: str = None, matcher = None, mode: PatchMode = None, value: str = None):
    target_path = Path('doxygen/out/html') / target
    patch_path = Path('doxygen/patches/') / target
    with open(target_path, 'r') as fis:
        contents = fis.readlines()

    if value is None and mode in [PatchMode.INSERT_AFTER]:
        value = patch_path.read_bytes().decode("utf-8")

    if type(matcher) is str:
        matcher_str = matcher
        matcher = lambda x: matcher_str in x


    def process():
        ok = False
        for line in contents:
            matcher_result = matcher(line)
            if matcher_result:
                ok = True
                if type(matcher_result) is str:
                    yield matcher_result
                elif mode == PatchMode.INSERT_AFTER:
                    yield line
                    yield value
                elif mode == PatchMode.DELETE_LINE:
                    pass
            else:
                yield line

        if not ok:
            raise RuntimeError(f"{target_path} does not contain anchor")

    with open(target_path, 'w') as out:
        for i in process():
            out.write(i)

########################################################################################################################

# AUI-specific checks here.

def check_is_valid_workdir():
    if not Path('README.md').exists():
        print(
            "Error: README.md does not exist in the current working directory. Are you running from proper working dir?")
        exit(-1)

def find_source_root(file: Path) -> Path:
    """
    Searches source root.
    :param path: some file in src/ directory, i.e., aui.views/src/AUI/Views.h
    :return: source root, i.e., aui.views/src
    """
    if file.name == "src":
        return file
    return find_source_root(file.parent)

class SourceLine:
    file: Path
    line_number: int

    def __init__(self, file: Path, line_number: int):
        self.file = file
        self.line_number = line_number

def check_all_are_in_group(directory: Path, group: str):
    expected = f"@ingroup {group}"
    ignore_tag = f"// ignore {group}"
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith(".h"):
                full_path = Path(root) / file
                def read(path: Path):
                    with open(path, 'r') as fis:
                        for line_number, line in enumerate(fis.readlines()):
                            if "// defined here" in line:
                                m = REGEX_INCLUDE.match(line)
                                if not m:
                                    report_error(path, "bad \"// defined here\" usage", line=line_number)
                                    continue
                                for s in read(find_source_root(path) / m.group(1)):
                                    yield s
                                continue

                            yield SourceLine(path, line_number), line

                contents = [i for i in read(full_path)]

                if any([ignore_tag in line[1] for line in contents]):
                    continue

                if not any(["@ingroup" in line[1] for line in contents]):
                    report_error(full_path,
                                 "no @ingroup statement in docs; either document with @ingroup or mark the include "
                                 "where the property is defined with \"// defined here\"")

                for src, line in contents:
                    if m := REGEX_INGROUP.match(line):
                        matching = m.group(1)
                        if matching != expected:
                            report_error(src.file, f"\"{matching}\" does not match \"{expected}\"", line=src.line_number)


########################################################################################################################

if __name__ == '__main__':
    check_is_valid_workdir()

    check_all_are_in_group(Path("aui.views/src/AUI/ASS/Property"), "ass_properties")
    check_all_are_in_group(Path("aui.views/src/AUI/ASS/Selector"), "ass_selectors")

    generate_docs_from_tests()
    invoke_doxygen()

    patch(target='classes.html', matcher='<div class="contents">', mode=PatchMode.INSERT_AFTER)

    # remove useless AUI Framework root element.
    patch(target='navtreedata.js', matcher='[ "AUI Framework", "index.html", [', value='', mode=PatchMode.DELETE_LINE)
    patch(target='navtreedata.js', matcher=lambda x: x == '  ] ]\n', value='', mode=PatchMode.DELETE_LINE)
    patch(target='navtree.js', matcher='o.breadcrumbs.unshift', mode=PatchMode.DELETE_LINE)

    # remove links from groups and instead make them toggle collapse/expand.
    def remove_link_from_group(line):
        # "usergroup0.html", [
        words = line.split(', ')
        if len(words) != 3:
            return False
        if words[2] != '[\n':
            return False
        if '"' not in words[1]:
            return False
        words[1] = "null"
        return ", ".join(words)

    patch(target='navtreedata.js', matcher=remove_link_from_group)

    # patch(target='navtree.js', anchor='(16*level)', value='(16*(level-1))', mode=PatchMode.REPLACE)
    # patch(target='navtree.js', anchor='(level+1)', value='level', mode=PatchMode.REPLACE)


    if error_flag:
        exit(-1)


    output_dir = Path(CONFIG['output'])
    for file in CONFIG['copy_to_output']:
        shutil.copytree(file, output_dir / Path(file).name, dirs_exist_ok=True)
        pass
