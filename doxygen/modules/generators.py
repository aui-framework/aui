#  AUI Framework - Declarative UI toolkit for modern C++20
#  Copyright (C) 2020-2024 Alex2772 and Contributors
#
#  SPDX-License-Identifier: MPL-2.0
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
import os
import subprocess
from pathlib import Path

from modules import regexes

CATEGORIES = [
    ('app', "Application Examples", "These examples typically go beyond single-file projects and delve into more substantial applications that showcase how multiple techniques can be integrated to create nearly production-ready applications. Each example not only demonstrates specific features of the AUI Framework but also covers practical aspects such as dependency management, data binding and user interface customization."),
    ('ui', "UI", "Various UI building samples."),
    ('desktop', "Desktop", "Desktop-specific examples."),
]


def docs_from_gen():
    BASE_DIR = Path('doxygen/gen')
    for script_filename in os.listdir(BASE_DIR):
        if not script_filename.endswith('.py'):
            continue
        with open(f'doxygen/intermediate/{script_filename[:-3]}.md', 'wb') as fos:
            process = subprocess.run(f'python3 {BASE_DIR / script_filename}', shell=True, capture_output=True)
            if process.returncode != 0:
                raise RuntimeError(f'Python subprocess failed: {process.stderr.decode("utf-8")}')
            fos.write(process.stdout)



def scan_cpp_files(path: Path):
    """
    # scans aui.*/tests/**.cpp files for the following line:
    #
    # // AUI_DOCS_OUTPUT: <path>
    """
    for root, dirs, files in os.walk(path):
        for file in files:
            if file.endswith('.cpp') and regexes.DIR.match(root):
                with open(Path(root) / file, 'r') as f:
                    for line in f.readlines():
                        if regexes.AUI_DOCS_OUTPUT.match(line):
                            yield Path(root) / file


def process_code_begin(iter):
    for _, line in iter:
        if "AUI_DOCS_CODE_END" in line:
            return
        yield line


def strip_indentation(code):
    """
    Removes unnecessary indentation.

    processes code as follows:
    [
      "    int main() {",
      "        return 0",
      "    }",
    ]

    to

    [
      "int main() {",
      "    return 0",
      "}",
    ]

    :param code: list of code lines
    :return modified list of code lines
    """
    min_leading_spaces = min([len(i) - len(i.lstrip()) for i in code])
    return [line[min_leading_spaces:] for line in code]


def process_cpp_file(input: Path):
    with open(input, 'r') as fis:
        lines = iter(enumerate(fis.readlines()))
        for line_number, line in lines:
            if m := regexes.AUI_DOCS_OUTPUT.match(line):
                output = Path(m.group(1))
                # Create a directory and file at the specified path if they don't exist
                output_dir = Path(output).parent
                os.makedirs(output_dir, exist_ok=True)
                break

        IS_MD = str(output).endswith(".md")
        with open(output, 'w') as fos:
            if IS_MD:
                def emit_line():
                    fos.write("\n")

                CODE_BEGIN = "```cpp"
                CODE_END = "```"
            else:
                def emit_line():
                    fos.write("\n * ")

                fos.write("\n\n\n/* !!!!!!!!!!!!!!!! THIS FILE IS AUTOGENERATED !!!!!!!!!!!!!!!! */\n\n\n")
                fos.write("/**")
                emit_line()
                CODE_BEGIN = "@code{cpp}"
                CODE_END = "@endcode"

            def emit_source_location_mark(line_number):
                fos.write(f'<b aui-src="{input.relative_to(os.getcwd())}#L{line_number+1}"></b>')
                emit_line()
            emit_source_location_mark(line_number)

            for line_number, line in lines:
                if match := regexes.TESTCASE_HEADER_H1.match(line):
                    emit_line()
                    fos.write("# ")
                    fos.write(match.group(3).replace("_", " "))
                    fos.write(" {#")
                    fos.write(f'{match.group(2)}_{match.group(3)}')
                    fos.write("}")
                    emit_line()
                    emit_source_location_mark(line_number)
                    continue

                if match := regexes.TESTCASE_HEADER_H2.match(line):
                    emit_line()
                    fos.write("## ")
                    fos.write(match.group(3).replace("_", " "))
                    fos.write(" {#")
                    fos.write(f'{match.group(2)}_{match.group(3)}')
                    fos.write("}")
                    emit_line()
                    emit_source_location_mark(line_number)
                    continue

                if comment := regexes.COMMENT.match(line):
                    comment_contents = comment.group(1)
                    if "AUI_DOCS_CODE_BEGIN" in comment_contents:
                        fos.write(CODE_BEGIN)
                        emit_line()
                        code = [i for i in process_code_begin(lines)]
                        for line in strip_indentation(code):
                            line = line.rstrip("\n")
                            if line.endswith("// HIDE"):
                                continue
                            fos.write(line)
                            emit_line()
                        fos.write(CODE_END)
                        emit_line()
                        emit_line()
                        continue
                    fos.write(comment_contents)
                    emit_line()

                if "#" in line:
                    emit_source_location_mark(line_number)

            if not IS_MD:
                fos.write("\n */")


def docs_from_tests():
    """
    The script generates a file under that path and places contents of the cpp file to the file
    with some preprocessing to make a suitable markdown file which can be used by Doxygen.

    This approach allows to generate decent docs with examples which would work based on the fact that they are generated
    from real tests.
    """

    suitable_cpp_files = [i for i in scan_cpp_files(Path.cwd())]
    print('Tests to generate docs from:', suitable_cpp_files)
    for path in suitable_cpp_files:
        process_cpp_file(path)


def docs_examples():
    EXAMPLES_DIR = Path.cwd() / "examples"

    examples = {}

    for root, dirs, files in os.walk(EXAMPLES_DIR):
        for file in files:
            if not file == "README.md":
                continue
            example_path = str(Path(root).relative_to(EXAMPLES_DIR))
            if not "/" in example_path:
                continue
            example_path = example_path.replace("/", "_")

            def collect_srcs(top):
                for root, dirs, files in os.walk(top):
                    for f in files:
                        if f.endswith(".h") or f.endswith(".cpp"):
                            yield Path(root) / f
            srcs = [i for i in collect_srcs(root)]

            input_file = Path(root) / file
            with open(input_file, 'r') as fis:
                page_path = f'doxygen/intermediate/{example_path}.md'
                with open(page_path, 'w') as fos:
                    title = fis.readline()
                    assert title.startswith("# ")
                    title = title.lstrip("# ").rstrip("\n")
                    if "{" in title:
                        fos.write("# ")
                        fos.write(title)
                        id = title[title.find("{#")+2:title.find("}")]
                        title= title[:title.find("{#")]
                    else:
                        fos.write(f"# {title}")
                        fos.write(" {#")
                        id = "example_" + title.lower().replace(" ", "_")
                        fos.write(id)
                        fos.write("}")
                    fos.write("\n\n")
                    category = None
                    description = ""
                    fos.write(f'<b aui-src="{input_file.relative_to(Path.cwd())}"></b>')
                    it = iter(fis.readlines())
                    for line in it:
                        fos.write(line)
                        if m := regexes.AUI_EXAMPLE.match(line):
                            category = m.group(1)
                            for description_line in it:
                                fos.write(description_line)
                                description_line = description_line.strip("\n")
                                if not description_line:
                                    break
                                description = description + " " + description_line
                    description = description.strip(" ")
                    if not id:
                        raise RuntimeError(f"no id provided in {input_file}")
                    if not category:
                        raise RuntimeError(f"no category provided in {input_file}")
                    if not description:
                        raise RuntimeError(f"no description provided in {input_file}")

                    current_category_list = examples.get(category, [])
                    current_category_list.append((id, description))
                    examples[category] = current_category_list
                    fos.write("\n\n")

                    assert category is not None

                    if not srcs:
                        continue
                    fos.write("\n\n# Source Files\n\n")
                    fos.write(f" - [Repository](https://github.com/aui-framework/aui/tree/master/{Path(root).relative_to(Path.cwd())})\n")
                    for src in srcs:
                        fos.write(f' - @ref {src.relative_to(Path.cwd())} "{src.relative_to(root)}"\n')

                    for src in srcs:
                        fos.write(f"@example {src.relative_to(Path.cwd())}\n")
                        fos.write("@note\n")
                        fos.write(f"This Source File belongs to @ref {page_path} \"{title}\" Example. Please follow the link for example explanation.\n")
                        fos.write("\n\n")

    if not examples:
        raise RuntimeError("no examples provided")

    with open("doxygen/intermediate/examples.md", "w") as fos:
        fos.write("# Examples {#examples}\n\n")
        fos.write("This document lists a collection of code samples and tutorials designed to help both newcomers and "
                  "experienced developers with AUI Framework app development. These projects cover diversity of "
                  "topics, from fundamental views usage through to complete application assembly.\n\n"
                  "# Building the Examples\n\n"
                  "To build these examples, simply clone [AUI repository](https://github.com/aui-framework/aui) and "
                  "configure CMake with `-DAUI_BUILD_EXAMPLES=TRUE`:\n"
                  "```\n"
                  "git clone https://github.com/aui-framework/aui\n"
                  "cd aui\n"
                  "mkdir build\n"
                  "cd build\n"
                  "cmake .. -DAUI_BUILD_EXAMPLES=TRUE\n"
                  "cmake --build . --parallel\n"
                  "```\n"
                  "Some of these examples are located outside of AUI's build tree; such examples should be compiled as "
                  "regular CMake projects."
                  "\n\n")
        for category in CATEGORIES:
            fos.write(f"# {category[1]} {{#examples_{category[0]}}}\n\n")
            fos.write(f"{category[2]}\n\n")
            fos.write("|  |  |\n")
            fos.write("|--|--|\n")

            category_list = examples[category[0]]
            for id, description in sorted(category_list, key=lambda x: x[0]):
                fos.write(f"| @ref {id} | {description} |\n")
            fos.write("\n\n")



