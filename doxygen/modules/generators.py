#  AUI Framework - Declarative UI toolkit for modern C++20
#  Copyright (C) 2020-2024 Alex2772 and Contributors
#
#  SPDX-License-Identifier: MPL-2.0
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
import os
import subprocess
from pathlib import Path

from modules import regexes


def docs_from_gen():
    BASE_DIR = Path('doxygen/gen')
    for script_filename in os.listdir(BASE_DIR):
        if not script_filename.endswith('.py'):
            continue
        with open(f'doxygen/intermediate/{script_filename[:-3]}.md', 'wb') as fos:
            process = subprocess.run(f'python3 {BASE_DIR / script_filename}', shell=True, capture_output=True)
            if process.returncode != 0:
                raise RuntimeError(f'Python subprocess failed: {process.stderr.decode("utf-8")}')
            fos.write(process.stdout)



def scan_cpp_files(path: Path):
    """
    # scans aui.*/tests/**.cpp files for the following line:
    #
    # // AUI_DOCS_OUTPUT: <path>
    """
    for root, dirs, files in os.walk(path):
        for file in files:
            if file.endswith('.cpp') and regexes.DIR.match(root):
                with open(Path(root) / file, 'r') as f:
                    for line in f.readlines():
                        if regexes.AUI_DOCS_OUTPUT.match(line):
                            yield Path(root) / file


def process_code_begin(iter):
    for _, line in iter:
        if "AUI_DOCS_CODE_END" in line:
            return
        yield line


def strip_indentation(code):
    """
    Removes unnecessary indentation.

    processes code as follows:
    [
      "    int main() {",
      "        return 0",
      "    }",
    ]

    to

    [
      "int main() {",
      "    return 0",
      "}",
    ]

    :param code: list of code lines
    :return modified list of code lines
    """
    min_leading_spaces = min([len(i) - len(i.lstrip()) for i in code])
    return [line[min_leading_spaces:] for line in code]


def process_cpp_file(input: Path):
    with open(input, 'r') as fis:
        lines = iter(enumerate(fis.readlines()))
        for line_number, line in lines:
            if m := regexes.AUI_DOCS_OUTPUT.match(line):
                output = Path(m.group(1))
                # Create a directory and file at the specified path if they don't exist
                output_dir = Path(output).parent
                os.makedirs(output_dir, exist_ok=True)
                break

        IS_MD = str(output).endswith(".md")
        with open(output, 'w') as fos:
            if IS_MD:
                def emit_line():
                    fos.write("\n")

                CODE_BEGIN = "```cpp"
                CODE_END = "```"
            else:
                def emit_line():
                    fos.write("\n * ")

                fos.write("\n\n\n/* !!!!!!!!!!!!!!!! THIS FILE IS AUTOGENERATED !!!!!!!!!!!!!!!! */\n\n\n")
                fos.write("/**")
                emit_line()
                CODE_BEGIN = "@code{cpp}"
                CODE_END = "@endcode"

            def emit_source_location_mark(line_number):
                fos.write(f'<b aui-src="{input.relative_to(os.getcwd())}#L{line_number+1}"></b>')
                emit_line()
            emit_source_location_mark(line_number)

            for line_number, line in lines:
                if match := regexes.TESTCASE_HEADER_H1.match(line):
                    emit_line()
                    fos.write("# ")
                    fos.write(match.group(3).replace("_", " "))
                    fos.write(" {#")
                    fos.write(f'{match.group(2)}_{match.group(3)}')
                    fos.write("}")
                    emit_line()
                    emit_source_location_mark(line_number)
                    continue

                if match := regexes.TESTCASE_HEADER_H2.match(line):
                    emit_line()
                    fos.write("## ")
                    fos.write(match.group(3).replace("_", " "))
                    fos.write(" {#")
                    fos.write(f'{match.group(2)}_{match.group(3)}')
                    fos.write("}")
                    emit_line()
                    emit_source_location_mark(line_number)
                    continue

                if comment := regexes.COMMENT.match(line):
                    comment_contents = comment.group(1)
                    if "AUI_DOCS_CODE_BEGIN" in comment_contents:
                        fos.write(CODE_BEGIN)
                        emit_line()
                        code = [i for i in process_code_begin(lines)]
                        for line in strip_indentation(code):
                            line = line.rstrip("\n")
                            if line.endswith("// HIDE"):
                                continue
                            fos.write(line)
                            emit_line()
                        fos.write(CODE_END)
                        emit_line()
                        emit_line()
                        continue
                    fos.write(comment_contents)
                    emit_line()

                if "#" in line:
                    emit_source_location_mark(line_number)

            if not IS_MD:
                fos.write("\n */")


def docs_from_tests():
    """
    The script generates a file under that path and places contents of the cpp file to the file
    with some preprocessing to make a suitable markdown file which can be used by Doxygen.

    This approach allows to generate decent docs with examples which would work based on the fact that they are generated
    from real tests.
    """

    suitable_cpp_files = [i for i in scan_cpp_files(Path.cwd())]
    print('Tests to generate docs from:', suitable_cpp_files)
    for path in suitable_cpp_files:
        process_cpp_file(path)
