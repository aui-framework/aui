/*
 * AUI Framework - Declarative UI toolkit for modern C++20
 * Copyright (C) 2020-2025 Alex2772 and Contributors
 *
 * SPDX-License-Identifier: MPL-2.0
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

#pragma once

#include <AUI/Common/AObject.h>
#include <AUI/Common/ASignal.h>
#include "ObjectLoader.h"


/**
 * @brief Hot code reload and rapid development
 * @details
 * While making UI-enabled applications, most of the time you will do the following:
 *
 * 1. Write some code.
 * 2. Compile it.
 * 3. Run the program.
 * 4. Open the menu/approach the feature you are working on.
 * 5. Check the result.
 * 6. Repeat steps 2-5 until you are satisfied with the result.
 *
 * Steps `2-5` are very slow and exhausting. This page briefly describes ways to speed up development of your
 * application.
 *
 * ## Precompiled headers
 *
 * Precompiled headers are a technique for speeding up compilation of C++ code.
 *
 * <INSERT EXAMPLE AND HOW TO DO THIS AND EXPLANATION HERE>
 *
 * ## The AHotCodeReload class
 *
 * The AHotCodeReload class is a helper class that allows you to reload the application
 * without restarting the application.
 *
 * | Platform     | Support |
 * | ------------ | ------- |
 * | [windows.md] | No      |
 * | [linux.md]   | Yes     |
 * | [macos.md]   | No      |
 * | [android.md] | No      |
 * | [ios.md]     | No      |
 *
 * It works by observing changes on object files, which are generated by compiler and picked up by linker.
 * AHotCodeReload implements its own linker designed specifically to load these intermediate build files and link them
 * against a program which is already running. Then, it scans for newly loaded functions and places hooks on old
 * versions of these functions, so the newer version is called.
 *
 * Unlike classic way of implementing hot code reload with dynamic libraries, approach implemented in AUI does not
 * interfere with build process nor require special project structure with complicated state management. It does not
 * replace older symbols with newer ones, it keeps them both in memory, so referencing both is safe.
 *
 * ### Usage
 *
 * 1. Launch target program.
 * 2. Change some source code.
 * 3. Recompile the program. You can skip linking step.
 * 4. Wait for patch to finish.
 * 5. Repeat steps 2-4 until you are satisfied with the result.
 *
 * ### Known limitations
 *
 * 1. While AHotCodeReload's linker performs safety checks before applying patches, it does not guarantee that the patch
 *    will not break the program.
 * 2. This module is specifically designed to patch functions only. Don't expect changing `static` or global variables
 *    will make effect - AHotCodeReload never reinitializes values.
 *    - Changes to local constants (such as string literals) will work.
 * 3. Changed functions must be called to observe the result. `AWindow::inflate`
 * 4. Do not change `struct` or `class` layouts. `AHotCodeReload` has no means to validate this.
 *
 */
class API_AUI_REMOTE_TOOLS AHotCodeReload : public AObject {
public:
    AHotCodeReload();
    ~AHotCodeReload();
    static AHotCodeReload& instance() {
        static AHotCodeReload instance;
        return instance;
    }

    void reload();

    emits<> patchBegin;
    emits<> patchEnd;

private:
    ObjectLoader mLoader;

};
